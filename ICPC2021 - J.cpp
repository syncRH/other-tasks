/*
J. Вежливые соседи
ограничение по времени на тест1 секунда
ограничение по памяти на тест256 мегабайт
вводстандартный ввод
выводстандартный вывод
Игорь и Ира решили поехать на дачу, ведь там куча дел: прополоть и полить грядки, собрать урожай, окучить картошку, проверить сохранность забора, уточнить наличие ящиков для хранения урожая и много-много всего.

Приехав на дачу, Игорь и Ира увидели, что никого из соседей не было. У Игоря и Иры все соседи на даче очень вежливые люди. Игорю стало интересно, кто из соседей уезжает с дачи каждый день, а кто остается ночевать. Для этого Игорь будет в течение дня записывать в блокнот следующие события:

+ k – сосед из домика под номером k приехал на свою дачу.
− k – сосед из домика под номером k сел в машину и собирается уехать.
Дачные участки стоят вдоль узкой дороги и пронумерованы от 1 до N. Когда соседи приезжают на дачу, они всегда хотят встать рядом со своим участком k, ведь так гораздо удобней. Они могут это сделать только в том случае, если перед участками с 1-го по k−1-й не стоят машины. Если соседи не могут проехать к своему дому, тогда они оставляют свою машину на общей парковке перед дачами.

Если сосед хочет уехать и его машина стоит на парковке, то он без проблем садится в машину и уезжает, если сосед хочет уехать и его машина стоит рядом с его участком, тогда он садится в машину и уезжает только в том случае, если на дороге не стоят машины перед участками с 1 по k−1, иначе он сидит и ждет, как вежливый сосед, пока не уедут все машины, которые мешают, если этого не получилось, то он остается на даче.

Соседи могут возвращаться и уезжать с дачи несколько раз.

Помогите Игорю – определите, кто из соседей в конце дня остался ночевать на даче, кто – уехал домой, а кто из соседей вообще не приезжал на дачу.

Входные данные
Первая строка содержит два целых числа N, M (1≤N,M≤105) – количество соседей и количество записей.

В следующих M строках содержатся записи в блокноте Игоря:

+ k (1≤k≤N) – на дачу с номером k приехал сосед.

− k (1≤k≤N) – с дачи номер k уезжает сосед.

Гарантируется, что перед операцией '+' соседа нет ни на участке, ни в машине рядом с участком.

Выходные данные
Для каждого i соседа выведите в i строке 'YES' (без кавычек), если сосед смог уехать домой, 'NO' (без кавычек), если сосед не уехал и остался ночевать на даче, '-1' (без кавычек) если сосед не приезжал на дачу.
*/

#include <iostream>
#include <string>
#include <vector>
#include <stack>
#include <map>
using namespace std;
 

/*
* Номера состояний и их расшифровка
* -1 - не приезжал на дачу
* 0 - сосед не приезжал.
* 1 - сосед на даче
* 2 - ожидает уезда
* 3 - стоит на парковке
* 4 - уехал с дачи.
*/
void neighborLeft(stack <int> &stackNeighbor, map <int, int> &mapNeighbor, int numberNeighbor) {
    for (int i = 1; i <= numberNeighbor; i++){
        if (mapNeighbor[i] != 1 && stackNeighbor.size() > 0) {
            if (stackNeighbor.top() == i) {
                mapNeighbor[i] = 4, stackNeighbor.pop();
            }
        }
        else break;
    }
}

int main()
{
    int n, m, neighbor;
    char action;
    bool(flag) = true;
    stack <int> stackNeighbor;
    map <int, int> mapNeighbor;
    stackNeighbor.push(100001);
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        cin >> action >> neighbor;
        if ((action == '+') && (neighbor < stackNeighbor.top())) stackNeighbor.push(neighbor), mapNeighbor[neighbor] = 1;
        else if (action == '+' && (neighbor > stackNeighbor.top())) mapNeighbor[neighbor] = 3;
        if ((action == '-') && (stackNeighbor.top() == neighbor)) stackNeighbor.pop(), mapNeighbor[neighbor] = 4;
        else if ((action == '-') && (stackNeighbor.top() != neighbor) && (mapNeighbor[neighbor] != 3)) {
            mapNeighbor[neighbor] = 2;
        }
        else if ((action == '-') && (mapNeighbor[neighbor] == 3)) mapNeighbor[neighbor] = 4;
        if ((action == '-') && (mapNeighbor[neighbor] != 3)) neighborLeft(stackNeighbor, mapNeighbor, n);
    }

    for (int i = 1; i <= n; i++)
    {
        if (mapNeighbor[i] == 4) cout << "YES" << endl;
        else if (mapNeighbor[i] == 1) cout << "NO" << endl;
        else if (mapNeighbor[i] == 2) cout << "NO" << endl;
        else if (mapNeighbor[i] == 3) cout << "NO" << endl;
        else if (mapNeighbor[i] == 0) cout << "-1" << endl;
    }

}